---
date: 2025-09-19T19:39:00+00:00
researcher: claude-opus-4.1
git_commit: 9f9f23efd446d46ef97f63949356c156f0221029
branch: main
repository: Context-Engineering-Intro
topic: "Seeding examples/ directory for Next.js + Supabase + Vercel MVP Context Engineering"
tags: [research, evidence-first, solo-rpi, next.js, supabase, vercel, context-engineering, examples]
status: complete
last_updated: 2025-09-19
last_updated_by: claude-opus-4.1
validation_review: complete
validation_by: peer-agent
---

# Research: Seeding examples/ Directory for Next.js + Supabase + Vercel MVP

**Date**: 2025-09-19T19:39:00+00:00
**Researcher**: claude-opus-4.1
**Git Commit**: 9f9f23efd446d46ef97f63949356c156f0221029
**Branch**: main
**Repository**: Context-Engineering-Intro

## Research Question
How to seed an examples/ directory that Context Engineering (CE) will imitate for a Next.js + Supabase + Vercel MVP, including CE conventions, authentication patterns, API routes, validation schemas, and testing scaffolds.

## Summary
Context Engineering relies heavily on the examples/ directory to guide AI implementations through pattern matching. Based on README.md:238-265, examples serve as "critical" references that AI coding assistants use to understand project conventions, code structure, testing patterns, and integration approaches. For a Next.js + Supabase + Vercel stack, the examples should demonstrate modern App Router patterns with @supabase/ssr for authentication, Zod for validation, server actions for mutations, and comprehensive test scaffolds that PRPs can copy directly.

The research reveals that successful Context Engineering requires concrete, working examples rather than documentation. Each example file should serve a single purpose and demonstrate production-ready patterns including error handling, type safety, and security best practices.

### Validation Findings (Peer Review)
After peer review, the following critical corrections were identified and incorporated:
1. **Path Resolution**: Examples must be under `web/examples/` with proper TypeScript path mapping to prevent build failures
2. **Cookie Handling**: Must match Supabase docs exactly - swallow errors in Server Components during `setAll`
3. **Validation Pattern**: Use `safeParse` with `result.success` branching instead of `parse` with try/catch
4. **Test Completeness**: Vitest examples now actually invoke server actions with FormData
5. **RLS Policies**: Added concrete SQL examples that PRPs can copy directly
6. **CI Pipeline**: Complete GitHub Actions workflow with all required steps

## Detailed Findings

### 1. Context Engineering Examples Influence on PRPs

**From Context Engineering README** (README.md:17-19, 238-265):
- Examples are placed in the `examples/` folder and are "highly recommended"
- AI performs "much better when they can see patterns to follow"
- Examples are referenced in INITIAL.md files to specify which patterns to follow
- The PRP generation process (README.md:195-199) analyzes codebase patterns and searches for similar implementations

**Key Requirements for Examples**:
- **Code Structure Patterns** (README.md:231-235): Module organization, import conventions, class/function patterns
- **Testing Patterns** (README.md:237-240): Test file structure, mocking approaches, assertion styles
- **Integration Patterns** (README.md:242-245): API client implementations, database connections, authentication flows
- **CLI Patterns** (README.md:247-250): Argument parsing, output formatting, error handling

**Recommended Structure** (README.md:253-264):
```
examples/
â”œâ”€â”€ README.md           # Explains what each example demonstrates
â”œâ”€â”€ cli.py             # CLI implementation pattern
â”œâ”€â”€ agent/             # Agent architecture patterns
â”‚   â”œâ”€â”€ agent.py      # Agent creation pattern
â”‚   â”œâ”€â”€ tools.py      # Tool implementation pattern
â”‚   â””â”€â”€ providers.py  # Multi-provider pattern
â””â”€â”€ tests/            # Testing patterns
    â”œâ”€â”€ test_agent.py # Unit test patterns
    â””â”€â”€ conftest.py   # Pytest configuration
```

### 2. Supabase Next.js SSR Patterns

**Core Implementation Requirements**:

**a. Supabase Client Setup** (@supabase/ssr pattern):
```typescript
// examples/supabase/client.ts - Browser client for Client Components
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
```

```typescript
// examples/supabase/server.ts - Server client for Server Components
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() { return cookieStore.getAll() },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // Ignore if called from Server Component
          }
        },
      },
    }
  )
}
```

**b. Authentication Server Actions**:
```typescript
// examples/auth/server-actions.ts
'use server'

import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'
import { createClient } from '@/examples/supabase/server'

export async function signIn(formData: FormData) {
  const supabase = await createClient()
  const data = {
    email: formData.get('email') as string,
    password: formData.get('password') as string,
  }
  const { error } = await supabase.auth.signInWithPassword(data)
  if (error) redirect('/error')
  revalidatePath('/', 'layout')
  redirect('/dashboard')
}

export async function signOut() {
  const supabase = await createClient()
  await supabase.auth.signOut()
  redirect('/login')
}
```

**c. Protected Server Component with RLS**:
```typescript
// examples/components/protected-profile.tsx
import { redirect } from 'next/navigation'
import { createClient } from '@/examples/supabase/server'

export async function ProtectedProfile() {
  const supabase = await createClient()
  const { data: { user }, error } = await supabase.auth.getUser()

  if (error || !user) redirect('/login')

  // Fetch RLS-protected data
  const { data: profile } = await supabase
    .from('profiles')
    .select('*')
    .single()

  return <div>Welcome {profile?.full_name || user.email}</div>
}
```

### 3. Next.js App Router Conventions

**Route Handler with Zod Validation (using safeParse)**:
```typescript
// web/examples/api/route-handler-zod.ts
// Place in app/api/items/route.ts for actual implementation
import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'

const createItemSchema = z.object({
  title: z.string().min(1).max(100),
  description: z.string().optional(),
  priority: z.enum(['low', 'medium', 'high']).default('medium')
})

export async function POST(request: NextRequest) {
  const body = await request.json()
  const result = createItemSchema.safeParse(body)

  if (!result.success) {
    return NextResponse.json(
      {
        error: 'Validation failed',
        details: result.error.issues.map(issue => ({
          field: issue.path.join('.'),
          message: issue.message
        }))
      },
      { status: 400 }
    )
  }

  // Process validated data with full type safety
  const validated = result.data

  // Your business logic here
  // const item = await db.items.create(validated)

  return NextResponse.json({
    success: true,
    data: validated
  })
}
```

### 4. Zod Schema Patterns

**Minimal User Schema**:
```typescript
// examples/schemas/user.schema.ts
import { z } from 'zod'

export const userSchema = z.object({
  email: z.string().email('Invalid email'),
  password: z.string().min(8, 'Password must be 8+ characters'),
  name: z.string().min(2).max(50).optional()
})

export type User = z.infer<typeof userSchema>

// Form validation in server action
export const signUpSchema = userSchema.extend({
  confirmPassword: z.string()
}).refine(data => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ['confirmPassword']
})
```

### 5. Test Scaffolds

**Vitest Unit Test**:
```typescript
// web/examples/tests/unit.sample.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { createClient } from '@/examples/supabase/server'
import { signIn } from '@/examples/auth/server-actions'

// Mock Next.js navigation
vi.mock('next/navigation', () => ({
  redirect: vi.fn(),
  revalidatePath: vi.fn()
}))

// Mock Supabase client
vi.mock('@/examples/supabase/server', () => ({
  createClient: vi.fn()
}))

describe('Authentication', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('should validate user credentials', async () => {
    const mockSupabase = {
      auth: {
        signInWithPassword: vi.fn().mockResolvedValue({
          data: { user: { id: '123', email: 'test@example.com' } },
          error: null
        })
      }
    }
    vi.mocked(createClient).mockResolvedValue(mockSupabase)

    // Create FormData to test the action
    const formData = new FormData()
    formData.set('email', 'test@example.com')
    formData.set('password', 'password123')

    // Call the server action
    await signIn(formData)

    // Assert the mock was called with correct data
    expect(mockSupabase.auth.signInWithPassword).toHaveBeenCalledWith({
      email: 'test@example.com',
      password: 'password123'
    })

    // Verify redirect was called
    const { redirect } = await import('next/navigation')
    expect(redirect).toHaveBeenCalledWith('/dashboard')
  })

  it('should handle sign in errors', async () => {
    const mockSupabase = {
      auth: {
        signInWithPassword: vi.fn().mockResolvedValue({
          data: null,
          error: { message: 'Invalid credentials' }
        })
      }
    }
    vi.mocked(createClient).mockResolvedValue(mockSupabase)

    const formData = new FormData()
    formData.set('email', 'test@example.com')
    formData.set('password', 'wrongpassword')

    await signIn(formData)

    const { redirect } = await import('next/navigation')
    expect(redirect).toHaveBeenCalledWith('/error')
  })
})
```

**Playwright E2E Test**:
```typescript
// web/examples/tests/auth.e2e.ts
import { test, expect } from '@playwright/test'

test.describe('Authentication Flow', () => {
  test.beforeEach(async ({ page }) => {
    // Ensure tests run against dev server
    // Start with: npm run dev
    // Then run: npm run e2e
  })

  test('should login and access dashboard', async ({ page }) => {
    await page.goto('/login')

    // Fill form
    await page.fill('input[name="email"]', 'test@example.com')
    await page.fill('input[name="password"]', 'testpass123')
    await page.click('button[type="submit"]')

    // Verify redirect to dashboard
    await expect(page).toHaveURL('/dashboard')
    await expect(page.locator('h1')).toContainText('Dashboard')
  })

  test('should protect routes', async ({ page }) => {
    // Try to access protected route without auth
    await page.goto('/dashboard')

    // Should redirect to login
    await expect(page).toHaveURL('/login')
  })
```

### 6. Database and RLS Policy Examples

**RLS Policy SQL Example**:
```sql
-- web/examples/database/rls-policies.sql
-- Enable RLS on profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only read their own profile
CREATE POLICY "Users can read own profile"
ON public.profiles
FOR SELECT
USING (auth.uid() = id);

-- Policy: Users can update their own profile
CREATE POLICY "Users can update own profile"
ON public.profiles
FOR UPDATE
USING (auth.uid() = id);

-- Policy: Automatic profile creation on signup
CREATE POLICY "Enable insert for authenticated users"
ON public.profiles
FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = id);

-- Example for a posts table with public read
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Posts are viewable by everyone"
ON public.posts
FOR SELECT
USING (true);

CREATE POLICY "Users can insert own posts"
ON public.posts
FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own posts"
ON public.posts
FOR UPDATE
USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own posts"
ON public.posts
FOR DELETE
USING (auth.uid() = user_id);
```

### 7. Environment Variables and CI Configuration

**.env.example**:
```bash
# web/examples/.env.example
# Copy this to .env.local and fill in your values
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key-here

# Optional: For testing
DATABASE_URL=postgresql://postgres:password@localhost:54322/postgres
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key-for-tests
```

**GitHub Actions CI Configuration**:
```yaml
# web/examples/ci/github-actions.yml
# Copy to .github/workflows/ci.yml
name: CI

on:
  pull_request:
    paths:
      - 'web/**'
      - '.github/workflows/ci.yml'
  push:
    branches:
      - main
    paths:
      - 'web/**'

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
          cache-dependency-path: web/package-lock.json

      - name: Install dependencies
        run: |
          cd web
          npm ci

      - name: Type check
        run: |
          cd web
          npm run -s typecheck || npx tsc --noEmit

      - name: Lint
        run: |
          cd web
          npm run lint

      - name: Unit tests
        run: |
          cd web
          npm test
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}

      - name: Install Playwright
        run: |
          cd web
          npx playwright install --with-deps

      - name: E2E tests
        run: |
          cd web
          npm run e2e
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}

      - uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: playwright-report
          path: web/playwright-report/
          retention-days: 30
```

### 8. Additional Required Examples

**Middleware for Auth**:
```typescript
// examples/middleware/auth.middleware.ts
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({ request })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() { return request.cookies.getAll() },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => {
            request.cookies.set(name, value)
            supabaseResponse.cookies.set(name, value, options)
          })
        },
      },
    }
  )

  await supabase.auth.getUser()
  return supabaseResponse
}
```

**RequireAuth Component**:
```typescript
// examples/components/RequireAuth.tsx
import { redirect } from 'next/navigation'
import { createClient } from '@/examples/supabase/server'

export async function RequireAuth({ children }: { children: React.ReactNode }) {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) redirect('/login')

  return <>{children}</>
}
```

## Code References
- `README.md:17-19` - Examples folder recommendation in quick start
- `README.md:238-265` - Using Examples Effectively section
- `README.md:195-199` - How generate-prp researches patterns
- External: Supabase SSR documentation for @supabase/ssr patterns
- External: Next.js App Router documentation for route.ts and server actions
- External: Zod documentation for validation schemas
- External: Vitest/Playwright guides for testing patterns

## Architecture Insights

The examples/ directory acts as a reference implementation that Context Engineering uses to:
1. **Pattern Match**: AI identifies similar code structures and mimics them
2. **Convention Enforcement**: Examples establish project-wide conventions
3. **Error Prevention**: Working examples prevent common implementation mistakes
4. **Type Safety**: TypeScript examples ensure proper type inference
5. **Security Patterns**: Examples demonstrate RLS, validation, and auth patterns

## Proposed File Structure

**CRITICAL**: Examples should be placed under `web/examples/` to align with Next.js project structure, with TypeScript path mapping configured.

```
web/
â”œâ”€â”€ tsconfig.json                      # Configure path mapping (see below)
â””â”€â”€ examples/
    â”œâ”€â”€ README.md                      # Explains each example's purpose
    â”œâ”€â”€ .env.example                   # Environment variables template
    â”œâ”€â”€ supabase/
    â”‚   â”œâ”€â”€ client.ts                 # Browser client for Client Components
    â”‚   â””â”€â”€ server.ts                 # Server client with cookie handling
    â”œâ”€â”€ auth/
    â”‚   â””â”€â”€ server-actions.ts          # signIn/signOut server actions
    â”œâ”€â”€ api/
    â”‚   â””â”€â”€ route-handler-zod.ts      # POST handler with Zod validation
    â”œâ”€â”€ schemas/
    â”‚   â””â”€â”€ user.schema.ts            # User schema with type inference
    â”œâ”€â”€ components/
    â”‚   â”œâ”€â”€ RequireAuth.tsx           # Auth wrapper component
    â”‚   â””â”€â”€ protected-profile.tsx     # RLS-protected data fetching
    â”œâ”€â”€ middleware/
    â”‚   â””â”€â”€ auth.middleware.ts        # Session refresh middleware
    â”œâ”€â”€ database/
    â”‚   â””â”€â”€ rls-policies.sql          # RLS policy examples for copying
    â”œâ”€â”€ ci/
    â”‚   â””â”€â”€ github-actions.yml        # CI pipeline configuration
    â””â”€â”€ tests/
        â”œâ”€â”€ unit.sample.test.ts       # Vitest unit test example
        â””â”€â”€ auth.e2e.ts               # Playwright E2E test example
```

### TypeScript Path Configuration

Add to `web/tsconfig.json`:
```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@/examples/*": ["examples/*"]
    }
  }
}
```

## Implementation Status

### âœ… Resolved Items

1. **Path Configuration**: Added TypeScript path mapping in `web/tsconfig.json` for `@/examples/*` imports
2. **RLS Policies**: Added comprehensive SQL examples in `web/examples/database/rls-policies.sql`
3. **CI Configuration**: Complete GitHub Actions workflow in `web/examples/ci/github-actions.yml`
4. **Environment Variables**: Added `.env.example` with required variables
5. **Test Improvements**:
   - Fixed Vitest to actually call server actions with FormData
   - Added error handling test cases
   - Clarified Playwright dev server requirement

### âš ï¸ Critical Implementation Notes

1. **Import Paths**: All examples must use `@/examples/*` imports after tsconfig.json configuration
2. **Cookie Handling**: Server client must swallow errors when `setAll` is called from Server Components
3. **Validation Pattern**: Always use `safeParse` with `result.success` branching (not `parse` with try/catch)
4. **Middleware Return**: Must return the `supabaseResponse` from `updateSession` function
5. **Server Actions**: Keep arguments serializable (FormData or plain objects)

### ğŸ”„ Open Decisions

1. **Supabase Auth vs BetterAuth**: Current examples use Supabase Auth. BetterAuth could be considered for:
   - More OAuth providers
   - Custom authentication flows
   - Session management flexibility
   - Decision impacts all auth examples and server action patterns

2. **Database Schema**: Need to define actual table structures for:
   - `profiles` table (id, user_id, full_name, avatar_url, created_at, updated_at)
   - Any additional application tables
   - Foreign key relationships
   - Indexes for performance

3. **Deployment Configuration**: Vercel-specific settings needed for:
   - Build command: `cd web && npm run build`
   - Output directory: `web/.next`
   - Environment variables mapping
   - Function region settings

4. **Error Boundaries**: Need examples for:
   - Global error boundary (`app/global-error.tsx`)
   - Route-specific error boundaries (`app/[route]/error.tsx`)
   - Async component error handling
   - Form validation error display patterns

5. **Advanced Patterns**: Consider adding examples for:
   - Parallel data fetching with Promise.all
   - Streaming with Suspense boundaries
   - Optimistic UI updates
   - Real-time subscriptions with Supabase

## Related Research
- Official Supabase Next.js SSR documentation
- Next.js 14+ App Router documentation
- Zod validation patterns research
- Vitest and Playwright documentation
- Claude Code slash commands and MCP integration patterns

## Recommendations for PRP Generation

When generating PRPs for this stack, ensure:
1. Reference specific example files for pattern consistency
2. Include validation gates for tests and type checking
3. Specify RLS policies for any new database tables
4. Use server actions for all mutations
5. Implement proper error boundaries and loading states
6. Follow the established file structure conventions
7. Include both unit and E2E test requirements